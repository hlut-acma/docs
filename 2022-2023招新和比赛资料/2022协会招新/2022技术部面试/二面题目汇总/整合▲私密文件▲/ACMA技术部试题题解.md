# ACMA技术部试题题解

## Problem A

直接模拟传染过程就行了

```c++
void solve(){
    ll x, n;cin >> x>> n;
    ll ans = 1;
    for(int i = 0;i < n;++i){
        ans += ans*x;
    }
    cout << ans << endl;
}
```

## Problem B

注意到 $a,b,c \ge 1$，我们可以贪心地组合出$[0,a+2*b+3*c]$中的所有数，所以答案是 $(a+2*b+3*c) \bmod 2$

## Problem C

贪心地考虑的话，我们从倒数第二棵树开始砍，对于每一棵树我们要一直砍使得a_i < a_i+1，如果在砍的过程中a_i+1 = 0了，那显然再怎么砍也无法满足要求。

## Problem D

因为题目最终求的是删数后最小的一个数，所以我们可以将问题直接转换为保留几位数字，使最后的数最小。于是，就有贪心的算法了： 首先，考虑第一位。将第一位所有可能的位置枚举一下，取最小且最前的一个。因为同样长度的数字比较看开头，于是这样便保证了第一位的最优性。要注意，要取最前的一个，尽量保留更多的可选数。而第二位就在第一个数之后的所有允许范围内枚举，方法同第一位。这样，取完了所有要取的数，然后输出就可以了。

## Problem E

​	扫一遍求出原ai的异或和sum，然后再扫一遍，对于每个i有$ans=max(ans,sum\bigoplus a_i\bigoplus b_i)$即可计算i位置上反转的结果。

​	最后输出ans即可。

## Problem F

题解：让所有人的顺序与原来相反那么就是让这个环逆序。

像一条直线上的数，让他们完全逆序就像冒泡一样进行，需要次数就是$n*(n-1)/2$

现在这里是个环，逆序我们把环看成两段，使每一段逆序次数相加就好了。

把环尽可能的等分成两段（为什么？设给分成两段，一段是$a$，则另一端$n-a$。需要次数$y=a*（a-1）/2+(n-a）*(n-a-a)/2$;可以求最小值，就是在a=n/2时）。

 

标程：

```c++
#include<bits/stdc++.h>
int main()
{
  Long long n,a;
  scanf("%lld",&n);
  a=n/2;
  n=n-a;
  printf("%lld\n",a*(a-1)/2+n*(n-1)/2);
}
```

## Problem G

​	我们从坐上走到右下的路径长度是确定的，就是n+m-1,所以要想最后结果为0，那么n+m-1一定是一个偶数，否则就不可能存在满足题目要求的路径。只有满足了这个条件我们才有继续分析的必要，我们可以求出来到达(i,j)这个格子时所有路径中数值和的最大值和最小值，0一定是介于两者之间的，否则也不可能存在满足题目要求的路径，所以只要0介于两者之间就一定有满足题意的一条路径存在。